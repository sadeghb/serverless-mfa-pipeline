# mfa_server.py
import logging
import os
import subprocess
import tempfile
from pathlib import Path

import flask
import requests as http_requests
import textgrid

from src.utils.config_loader import load_config

# --- Logging Configuration ---
# Set up a basic logger for the application.
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# --- Flask App and Config Initialization ---
app = flask.Flask(__name__)

try:
    CONFIG = load_config()
    app.logger.info("Configuration loaded successfully.")
except Exception as e:
    app.logger.critical(f"CRITICAL: Error loading configuration. Server cannot start. Error: {e}")
    CONFIG = None


# --- Helper Functions ---

def _parse_textgrid_to_json(textgrid_path: Path, logger: logging.Logger):
    """
    Parses a TextGrid file generated by MFA and extracts word alignments.

    Args:
        textgrid_path: The path to the .TextGrid file.
        logger: The Flask app logger for logging messages.

    Returns:
        A list of {"word": str, "interval": [start, end]} dictionaries or None on error.
    """
    if not textgrid_path.exists():
        logger.error(f"TextGrid file not found at: {textgrid_path}")
        return None

    try:
        tg = textgrid.TextGrid.fromFile(str(textgrid_path))
        # Find the 'words' tier, with a fallback to the first available interval tier.
        word_tier = next((tier for tier in tg.tiers if tier.name == 'words'), None)
        if not word_tier:
            logger.warning("Could not find 'words' tier. Attempting to find first IntervalTier.")
            word_tier = next((tier for tier in tg.tiers if isinstance(tier, textgrid.IntervalTier)), None)
        
        if not word_tier:
            logger.error("No suitable 'words' or IntervalTier found in TextGrid file.")
            return None

        alignments = []
        for interval in word_tier:
            # Only include intervals that represent actual words (not silence).
            if interval.mark and interval.mark.strip():
                alignments.append({
                    "word": interval.mark.strip(),
                    "interval": [round(interval.minTime, 3), round(interval.maxTime, 3)]
                })
        return alignments
    except Exception as e:
        logger.error(f"Failed to read or parse TextGrid file: {e}")
        return None


def _get_mfa_models(language_code: str, logger: logging.Logger) -> tuple[str | None, str | None]:
    """
    Determines the correct MFA dictionary and acoustic model paths from the config.
    
    Args:
        language_code: The language code from the client request (e.g., "en-US").
        logger: The Flask app logger.

    Returns:
        A tuple containing the paths for the dictionary and acoustic model.
    """
    # For this public version, model paths are hardcoded as they are fixed
    # within the Docker container's environment. The config structure is
    # shown for demonstration of a more extensible system.
    dictionary_path = "/opt/mfa_models/dictionary.dict"
    acoustic_model_path = "/opt/mfa_models/acoustic.zip"
    
    logger.info(f"Using MFA Dictionary: '{dictionary_path}', Acoustic Model: '{acoustic_model_path}'")
    return dictionary_path, acoustic_model_path


def _download_audio(audio_url: str, target_path: Path, logger: logging.Logger) -> bool:
    """
    Downloads an audio file from a URL to a local path.

    Args:
        audio_url: The public URL of the audio file.
        target_path: The local Path object where the file will be saved.
        logger: The Flask app logger.

    Returns:
        True on successful download, False otherwise.
    """
    try:
        response = http_requests.get(audio_url, stream=True, timeout=30)
        response.raise_for_status()
        with open(target_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
        logger.info(f"Audio downloaded to: {target_path}")
        return True
    except http_requests.exceptions.RequestException as e:
        logger.error(f"Failed to download audio from {audio_url}: {e}")
        return False


def _run_mfa_alignment(corpus_dir: Path, output_dir: Path, dict_path: str, model_path: str, logger: logging.Logger) -> bool:
    """
    Runs the 'mfa align' command as a subprocess.

    Args:
        corpus_dir: The directory containing the .wav and .lab files.
        output_dir: The directory where MFA will write the .TextGrid file.
        dict_path: Path to the MFA dictionary file.
        model_path: Path to the MFA acoustic model file.
        logger: The Flask app logger.

    Returns:
        True on success, False on failure.
    """
    # Command to run Montreal Forced Aligner. Using --num_jobs 1 is crucial
    # in a resource-constrained environment like Lambda.
    command = [
        "mfa", "align", str(corpus_dir), dict_path, model_path, str(output_dir),
        "--clean", "--num_jobs", "1"
    ]
    logger.info(f"Executing MFA command: {' '.join(command)}")
        
    try:
        # Execute the command, capturing output and checking for errors.
        process = subprocess.run(
            command, check=True, capture_output=True, text=True, encoding='utf-8'
        )
        logger.info("MFA process completed successfully.")
        # MFA sometimes outputs useful info to stderr, so we log it as a warning.
        if process.stderr:
            logger.warning(f"MFA STDERR:\n{process.stderr}")
        return True
    except subprocess.CalledProcessError as e:
        # This block catches errors from the MFA process itself.
        logger.error(f"MFA process failed with return code: {e.returncode}")
        if e.stdout: logger.error(f"MFA STDOUT (on error):\n{e.stdout}")
        if e.stderr: logger.error(f"MFA STDERR (on error):\n{e.stderr}")
        return False


# --- Flask Endpoint ---
@app.route('/align', methods=['POST'])
def align_audio():
    """Main API endpoint to perform forced alignment."""
    if CONFIG is None:
        app.logger.error("Server not properly configured. Aborting request.")
        return flask.jsonify({"error_message": "Server configuration error."}), 500

    # --- Step 1: Validate Input ---
    if not flask.request.is_json:
        return flask.jsonify({"error_message": "Request must be JSON."}), 400

    data = flask.request.get_json()
    audio_url = data.get('audio_url')
    transcript_text = data.get('transcript')
    language_code = data.get('language')

    if not all([audio_url, transcript_text, language_code]):
        return flask.jsonify({"error_message": "Missing 'audio_url', 'transcript', or 'language'."}), 400

    app.logger.info(f"Received request for language '{language_code}' with transcript: '{transcript_text[:50]}...'")
    dictionary, acoustic_model = _get_mfa_models(language_code, app.logger)
    if not dictionary or not acoustic_model:
        return flask.jsonify({"error_message": "Server configuration error for MFA models."}), 500

    # --- Step 2: Prepare Corpus in a Temporary Directory ---
    # Using a TemporaryDirectory ensures all files are cleaned up automatically.
    try:
        with tempfile.TemporaryDirectory() as temp_dir_str:
            temp_dir = Path(temp_dir_str)
            app.logger.info(f"Created temporary directory: {temp_dir}")

            # Download the audio file.
            audio_filename = "input_audio.wav"
            local_audio_path = temp_dir / audio_filename
            if not _download_audio(audio_url, local_audio_path, app.logger):
                return flask.jsonify({"error_message": "Failed to download audio"}), 400

            # Write the transcript to a .lab file, which MFA expects.
            transcript_filename = local_audio_path.stem + ".lab"
            local_transcript_path = temp_dir / transcript_filename
            with open(local_transcript_path, 'w', encoding='utf-8') as f:
                f.write(' '.join(transcript_text.strip().split())) # Normalize whitespace
            
            # --- Step 3: Run MFA Alignment ---
            mfa_output_dir = temp_dir / "mfa_output"
            if not _run_mfa_alignment(temp_dir, mfa_output_dir, dictionary, acoustic_model, app.logger):
                return flask.jsonify({"error_message": "MFA alignment process failed."}), 500

            # --- Step 4: Find and Parse the Output ---
            # Robustly search for the output .TextGrid file.
            textgrid_files = list(mfa_output_dir.rglob("*.TextGrid"))
            if not textgrid_files:
                app.logger.error(f"MFA ran but no .TextGrid file was found in {mfa_output_dir}.")
                return flask.jsonify({"error_message": "MFA produced no parseable output."}), 500
            
            final_textgrid_path = textgrid_files[0]
            app.logger.info(f"Found TextGrid at: {final_textgrid_path}")

            alignments = _parse_textgrid_to_json(final_textgrid_path, app.logger)
            if alignments is None:
                return flask.jsonify({"error_message": "Failed to parse alignment output."}), 500

            app.logger.info(f"Successfully generated {len(alignments)} word alignments.")
            return flask.jsonify(alignments), 200

    except Exception as e:
        app.logger.error(f"An unexpected error occurred in /align: {e}", exc_info=True)
        return flask.jsonify({"error_message": "An unexpected server error occurred."}), 500


if __name__ == '__main__':
    # This block is for local development only.
    # In production, a WSGI server like Gunicorn is used via the Docker CMD.
    app.run(host='0.0.0.0', port=5000, debug=True)
